[1강 자바스크립트 기본 문법 총정리]

1. 자바스크립트를 사용하는 이유
  - HTML 요소를 변경하기 위해

2. 버튼을 누르면서 뭔가를 실행하고 싶으면 이벤트 리스너를 사용한다.

3. 잠깐 자료를 저장하고 싶으면 변수를 사용한다.

4. 긴 코드를 축약하고 싶으면 함수를 만든다.

5. 함수를 다양하게 쓰려면 파라미터를 사용한다.

6. 여러 개의 자료를 저장하려면 array와 object를 사용한다.

7. 코드를 조건문으로 실행하고 싶으면 if / else 구문을 사용한다.

8. 반복되는 코드를 줄이고 싶으면 for 문을 사용한다.

[2강 함수와 object에서 사용되는 this 키워드의 의미]

1. 그냥 쓰거나 일반 함수 안에서 작성할 경우 window 오브젝트(global object)
   → 참고 : 함수나 변수를 전역 공간에서 만들면 window에 보관된다.

2. 오브젝트에 할당된 함수인 메소드를 가지고 있는 오브젝트
   → 참고 : 일반 함수를 화살표 함수로 작성하면 바깥 함수의 this 값이 적용됨.

3. strict mode로 설정하고 일반 함수 안에서 작성할 경우 undefined

[3강 event listener와 constructor에서 사용되는 this 키워드의 의미]

1. constructor 안에서 쓰면 constructor로부터 새로 생성되는 오브젝트(instance)

2. event Listener 안에서 쓰면 e.currentTarget

[4강 Arrow function이란 무엇인가?]

⦿ 함수를 사용하는 이유
   - 재사용할 수 있는 어떤 기능을 만들기 위해 작성한 코드들을 묶고 싶을 때

⦿ 화살표 함수의 장점
   - 파라미터가 1개일 때 생략 가능.
   - 코드가 1줄이면 중괄호와 return 키워드 생략 가능.
   - 함수 본연의 기능인 입출력 기능을 만들 때 function 키워드보다 가독성이 좋음.

⦿ 화살표 함수의 특징
   - 바깥 함수의 this 값을 함수 내부에서 그대로 사용.

[5강 변수란 무엇인가?]

⦿ 정의
   - 자료를 임시로 저장하는 공간

⦿ 형식
   - var 변수 이름 = 저장할 값

⦿ 특징 → 선언과 할당, 범위 중심으로
   - var 키워드 : 재선언 (O), 재할당 (O), 범위 : 함수 스코프(function scope) 
   - let 키워드 : 재선언 (X), 재할당 (O), 범위 : 블록 스코프(block scope) 
   - const 키워드 : 재선언 (X), 재할당 (X), 범위 : 블록 스코프(block scope) 

⦿ 참고 사항
   - const 변수로 오브젝트를 만들 때 오브젝트 내부 값을 변경해도 에러가 발생하지 않음. 왜냐히면, const 변수 자체를 재할당한 것이 아니므로.
   - 수정 불가능한 오브젝트를 만들고 싶으면 Object.freeze(변수 이름)를 사용한다. 
   - 호이스팅 : 변수와 함수는 작성한 코드의 위치에 상관없이 변수와 함수의 선언 부분을 코드의 최상단으로 끌어올리는 현상
   - 전역 변수 : 모든 곳에서 접근할 수 있는 변수
     → 참고 사이트 : https://developer-talk.tistory.com/547
   - 변수 스코프와 관련된 연습 문제
     if(true) {
       let a = 1;
       var b = 2;
       if(true) {
         let b = 3;
       }
       console.log(b); // 2
     }

[6강 자바스크립트가 문자를 다루는 신기한 방법]

⦿ Template literals의 정의
   - backtick(backquote)을 이용하여 문자를 다루는 기법

⦿ Template literals의 장점
   - 엔터키 기능
   - 따옴표와 비교하여 변수를 적용하기 쉬움.

⦿ Tagged literals의 정의
   - 함수를 이용하여 문자들을 해체 분석하는 기법

⦿ Tagged literals의 특징
   - 단어 순서를 변경하거나 단어 제거, 변수 위치 변경 등의 작업이 가능하다.
   - 해체 분석기의 첫 번쩨 파라미터는 ${변수명} 기준으로 문자열들을 array해 준 파라미터.
   - 해체 분석기의 두 번쩨 파라미터는 변수를 저장하는 파라미터.

[7강 Spread Operator란 무엇인가?]

⦿ 정의
   - ...을 이용하여 괄호를 제거하고 배열과 문자열의 원소, 객체의 속성들을 나열하는 연산자

⦿ 용도
   - 배열들을 합치거나 깊은 복사(Deep copy : 독립적인 값들 복사)할 때
   - 오브젝트들을 합치거나 깊은 복사할 때
   - 배열의 원소들을 함수의 파라미터로 넣을 때

⦿ 특징
   - Array 대괄호와 Object 중괄호, function 소괄호 안에서만 쓰임. 

⦿ 참고 사항
   - apply() 함수는 파라미터를 Array 형태로 추가할 수 있지만 call() 함수는 그렇지 않음. 

[8강 함수 업그레이드하기 - default parameter / arguments]

⦿ 함수의 특징
   - 파라미터 갯수와 함수 인수의 갯수가 달라도 에러는 발생하지 않음. 
   - default parameter에 수학 연산자와 함수도 사용할 수 있음. 

⦿ arguments 키워드
   - 정의 : 함수에 전달된 모든 인수를 Array 형태로 나타낸 객체
   - 용도 : 모든 인수를 한꺼번에 다루고 싶을 때

[9강 Rest Parameter란 무엇인가?]

⦿ 정의
   - 함수 안에 들어온 인수를 Array 형태로 나타낸 파리미터

⦿ 특징
   - 매개변수의 가장 뒤애 작성함.
     ex) function test(...rest, a) {} → (X)
     ex) function test(a, ...rest) {} → (O)
   - 2번 이상 사용 금지.
     ex) function test(...rest, ...rest2) {} → (X)
     ex) function test(...rest) {} → (O)

⦿ arguments 키워드와의 차이점
   - Array 안에 arguments 키워드는 모든 파라미터들을 담지만 Rest Parameter는 특정 파라미터를 보관할 수 있음.
   - arguments 키워드는 파라미터의 갯수를 지정하지만 Rest Parameter는 그럴 필요가 없음.

[10강 Primitive data type과 Reference data type이란 무엇인가?]

⦿ Primitive data type의 정의
   - 변수에 값이 저장되는 데이터 타입

⦿ Primitive data type의 종류
   - String, number, Boolean, undefined, null, Symbol

⦿ Reference data type의 정의
   - 변수에 reference가 저장되는 데이터 타입
   
⦿ Reference data type의 종류
   - Array, Object

⦿ Reference data type의 특징
   - Array와 Object를 만들 때마다 별개의 Reference가 생김.
   - 파라미터는 변수 생성 및 할당과 동일하다고 여겨야 됨.

[11강 객체 지향 1 - constructor(생성자)란 무엇인가?]

⦿ 정의
   - object를 생성하는 기계

⦿ 용도
   - object를 여러 개 만들고 싶을 때

⦿ 특징
   - constructor를 함수로 만들 경우, 관습적으로 함수 이름의 첫 번째 글자는 대문자임.

[12강 객체 지향 2 - prototype이란 무엇인가?]

⦿ 정의
   - 부모의 유전자 역할을 담당하는 비밀 공간
   - 직역하면 원형을 의미하지만 유전자로 이해하는 것이 편함.
 
⦿ 특징
   - prototype에 값을 여러개 부여할 수 있고 함수도 추가할 수 있다. 
   - prototype에 값을 추가하면 모든 자식들이 값을 물려받을 수 있다.
   - prototype에 추가된 값은 부모만 가지고 있다.
   - 함수로 constructor를 만들면 prototype이 자동으로 생성된다.
   - 내 부모 유전자(부모의 prototype)를 검사하고 싶으면 '__proto__'를 사용한다.
   - '__proto__'를 직접 등록하면 object끼리 상속을 구현할 수 있다.

⦿ 동작 원리
   - 내가 직접 값을 가지고 있는지 검사한다.
   - 내가 값을 가지고 있지 않으면 부모 유전자들이 값을 가지고 있는지 차례대로 검사한다.

⦿ 상속을 구현하는 방법인 constructor와 prototype의 차이점
   - 자식들이 값을 직접 소유하게 만들고 싶으면 constructor를 사용
   - 부모만 값을 가지고 자식은 그것을 참조해서 쓰게 만들려면 prototype을 사용